// Generated by CoffeeScript 1.9.2
var createEvent, deferred, emit, fs, mkpath, normalize, pipeline, recurse, ref, ref1;

ref = require('../pipeline'), createEvent = ref.createEvent, emit = ref.emit;

ref1 = require('also'), pipeline = ref1.pipeline, deferred = ref1.deferred;

normalize = require('path').normalize;

mkpath = require('mkpath');

fs = require('fs');

createEvent('recurse.start');

createEvent('recurse.entering');

createEvent('recurse.found');

createEvent('recurse.end');

createEvent('recurse.error');

module.exports = function(paths, optionsORcallback, callback) {
  var options, path;
  options = optionsORcallback;
  if (typeof optionsORcallback === 'function') {
    callback = optionsORcallback;
    options = {};
  }
  if (paths.constructor.name !== 'Array') {
    paths = [paths];
  }
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var reject, resolve;
          resolve = arg.resolve, reject = arg.reject;
          return emit('recurse.start', {
            path: path
          }, function(err, res) {
            if (err != null) {
              return reject(err);
            }
            return recurse([path], options, function(err, res) {
              if (err != null) {
                return reject(err);
              }
              return emit('recurse.end', {
                path: path
              }, function() {
                return resolve(res);
              });
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return emit('recurse.error', error, function() {
      return callback(error);
    });
  });
};

recurse = function(paths, options, callback) {
  var path;
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var e, reject, resolve, stat;
          resolve = arg.resolve, reject = arg.reject;
          if (path.match(/^\//)) {
            return reject(new Error('Cannot recurse from root.'));
          }
          try {
            stat = fs.lstatSync(path);
            if (!stat.isDirectory()) {
              return reject(new Error('Cannot recurse file ' + path));
            }
          } catch (_error) {
            e = _error;
            if (e.errno !== 34) {
              return reject(e);
            }
            if (!options.create) {
              return reject(e);
            }
            try {
              mkpath.sync(path);
            } catch (_error) {
              e = _error;
              return reject(e);
            }
          }
          return emit('recurse.entering', {
            path: path
          }, function(err) {
            var contents, directories, f, file, files, j, len1;
            if (err != null) {
              return reject(err);
            }
            contents = fs.readdirSync(path);
            files = [];
            directories = [];
            for (j = 0, len1 = contents.length; j < len1; j++) {
              f = contents[j];
              f = path + '/' + f;
              try {
                stat = fs.lstatSync(f);
                if (stat.isDirectory()) {
                  directories.push(f);
                  continue;
                }
                files.push(f);
              } catch (_error) {
                e = _error;
                return reject(e);
              }
            }
            return pipeline((function() {
              var k, len2, results1;
              results1 = [];
              for (k = 0, len2 = files.length; k < len2; k++) {
                file = files[k];
                results1.push((function(file) {
                  return deferred(function(arg1) {
                    var reject, resolve;
                    resolve = arg1.resolve, reject = arg1.reject;
                    return emit('recurse.found', {
                      path: file
                    }, function(err) {
                      if (err != null) {
                        return reject(err);
                      }
                      return resolve();
                    });
                  });
                })(file));
              }
              return results1;
            })()).then(function(result) {
              return recurse(directories, options, function(err, res) {
                if (err != null) {
                  return reject(err);
                }
                return resolve(res);
              });
            }, function(error) {
              return reject(error);
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return callback(error);
  }, function(notify) {});
};
