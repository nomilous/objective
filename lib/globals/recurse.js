// Generated by CoffeeScript 1.9.2
var TODO, createEvent, debug, deferred, emit, error, fs, info, isBinaryFile, mkpath, normalize, pipeline, recurse, ref, ref1, ref2, ref3, sep;

ref = objective.logger, info = ref.info, error = ref.error, TODO = ref.TODO;

debug = objective.logger.createDebug('recurse');

ref1 = require('./pipeline'), createEvent = ref1.createEvent, emit = ref1.emit;

ref2 = require('also'), pipeline = ref2.pipeline, deferred = ref2.deferred;

ref3 = require('path'), normalize = ref3.normalize, sep = ref3.sep;

mkpath = require('mkpath');

try {
  isBinaryFile = require('isBinaryFile');
} catch (_error) {}

fs = require('fs');

createEvent('files.recurse.start');

createEvent('files.recurse.entering');

createEvent('files.recurse.found');

createEvent('files.recurse.end');

createEvent('files.recurse.error');

createEvent('files.recurse.changed');

module.exports = function(paths, optionsORcallback, callback) {
  var options, path;
  info("Recursing " + (JSON.stringify(paths)));
  options = optionsORcallback;
  if (typeof optionsORcallback === 'function') {
    callback = optionsORcallback;
    options = {};
  }
  if (paths.constructor.name !== 'Array') {
    paths = [paths];
  }
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var reject, resolve;
          resolve = arg.resolve, reject = arg.reject;
          return emit('files.recurse.start', {
            path: path
          }, function(err, res) {
            if (err != null) {
              return reject(err);
            }
            return recurse([path], options, function(err, res) {
              if (err != null) {
                return reject(err);
              }
              return emit('files.recurse.end', {
                path: path
              }, function() {
                return resolve(res);
              });
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return emit('files.recurse.error', error, function() {
      return callback(error);
    });
  });
};

recurse = function(paths, options, callback) {
  var path;
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var e, reject, resolve, stat;
          resolve = arg.resolve, reject = arg.reject;
          if (path.match(/^\//)) {
            return reject(new Error('Cannot recurse from root.'));
          }
          try {
            stat = fs.lstatSync(path);
            if (!stat.isDirectory()) {
              return reject(new Error('Cannot recurse file ' + path));
            }
          } catch (_error) {
            e = _error;
            if (e.errno !== 34) {
              return reject(e);
            }
            if (!options.createDir) {
              return reject(e);
            }
            try {
              mkpath.sync(path);
            } catch (_error) {
              e = _error;
              return reject(e);
            }
          }
          return emit('files.recurse.entering', {
            path: path
          }, function(err) {
            var contents, directories, f, file, files, j, len1;
            if (err != null) {
              return reject(err);
            }
            contents = fs.readdirSync(path);
            files = [];
            directories = [];
            for (j = 0, len1 = contents.length; j < len1; j++) {
              f = contents[j];
              f = path + sep + f;
              try {
                stat = fs.lstatSync(f);
                if (stat.isDirectory()) {
                  directories.push(f);
                  continue;
                }
                files.push(f);
              } catch (_error) {
                e = _error;
                return reject(e);
              }
            }
            return pipeline((function() {
              var k, len2, results1;
              results1 = [];
              for (k = 0, len2 = files.length; k < len2; k++) {
                file = files[k];
                results1.push((function(file) {
                  return deferred(function(arg1) {
                    var reject, resolve;
                    resolve = arg1.resolve, reject = arg1.reject;
                    debug("recursor found file " + file);
                    return emit('files.recurse.found', {
                      path: file,
                      watch: false,
                      load: false
                    }, function(err, arg2) {
                      var load, watch;
                      watch = arg2.watch, load = arg2.load;
                      if (err != null) {
                        return reject(err);
                      }
                      try {
                        if (isBinaryFile(file)) {
                          return resolve();
                        }
                      } catch (_error) {}
                      if (watch) {
                        fs.watchFile(file, {
                          interval: 100
                        }, function(curr, prev) {
                          if (!(prev.mtime < curr.mtime)) {
                            return;
                          }
                          return emit('files.recurse.changed', {
                            path: file
                          }, function() {});
                        });
                      }
                      if (load) {
                        try {
                          require(process.cwd() + sep + file);
                          return resolve();
                        } catch (_error) {
                          e = _error;
                          return reject(e);
                        }
                      }
                      return resolve();
                    });
                  });
                })(file));
              }
              return results1;
            })()).then(function(result) {
              return recurse(directories, options, function(err, res) {
                if (err != null) {
                  return reject(err);
                }
                return resolve(res);
              });
            }, function(error) {
              return reject(error);
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return callback(error);
  }, function(notify) {});
};
