// Generated by CoffeeScript 1.9.2
var createEvent, debug, deferred, emit, error, fs, info, isBinaryFile, mkpath, normalize, pipeline, recurse, ref, ref1, ref2, ref3, sep;

ref = require('./pipeline'), createEvent = ref.createEvent, emit = ref.emit;

ref1 = require('also'), pipeline = ref1.pipeline, deferred = ref1.deferred;

ref2 = require('path'), normalize = ref2.normalize, sep = ref2.sep;

mkpath = require('mkpath');

try {
  isBinaryFile = require('isBinaryFile');
} catch (_error) {}

fs = require('fs');

ref3 = require('../logger'), info = ref3.info, debug = ref3.debug, error = ref3.error;

createEvent('files.recurse.start');

createEvent('files.recurse.entering');

createEvent('files.recurse.found');

createEvent('files.recurse.end');

createEvent('files.recurse.error');

createEvent('files.recurse.load?');

createEvent('files.recurse.load.fatal?');

createEvent('files.watch.reload?');

module.exports = function(paths, optionsORcallback, callback) {
  var options, path;
  info("Recursing " + (JSON.stringify(paths)));
  options = optionsORcallback;
  if (typeof optionsORcallback === 'function') {
    callback = optionsORcallback;
    options = {};
  }
  if (paths.constructor.name !== 'Array') {
    paths = [paths];
  }
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var reject, resolve;
          resolve = arg.resolve, reject = arg.reject;
          return emit('files.recurse.start', {
            path: path
          }, function(err, res) {
            if (err != null) {
              return reject(err);
            }
            return recurse([path], options, function(err, res) {
              if (err != null) {
                return reject(err);
              }
              return emit('files.recurse.end', {
                path: path
              }, function() {
                return resolve(res);
              });
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return emit('files.recurse.error', error, function() {
      return callback(error);
    });
  });
};

recurse = function(paths, options, callback) {
  var path;
  return pipeline((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];
      results.push((function(path) {
        return deferred(function(arg) {
          var e, reject, resolve, stat;
          resolve = arg.resolve, reject = arg.reject;
          if (path.match(/^\//)) {
            return reject(new Error('Cannot recurse from root.'));
          }
          try {
            stat = fs.lstatSync(path);
            if (!stat.isDirectory()) {
              return reject(new Error('Cannot recurse file ' + path));
            }
          } catch (_error) {
            e = _error;
            if (e.errno !== 34) {
              return reject(e);
            }
            if (!options.createDir) {
              return reject(e);
            }
            try {
              mkpath.sync(path);
            } catch (_error) {
              e = _error;
              return reject(e);
            }
          }
          return emit('files.recurse.entering', {
            path: path
          }, function(err) {
            var contents, directories, f, file, files, j, len1;
            if (err != null) {
              return reject(err);
            }
            contents = fs.readdirSync(path);
            files = [];
            directories = [];
            for (j = 0, len1 = contents.length; j < len1; j++) {
              f = contents[j];
              f = path + sep + f;
              try {
                stat = fs.lstatSync(f);
                if (stat.isDirectory()) {
                  directories.push(f);
                  continue;
                }
                files.push(f);
              } catch (_error) {
                e = _error;
                return reject(e);
              }
            }
            return pipeline((function() {
              var k, len2, results1;
              results1 = [];
              for (k = 0, len2 = files.length; k < len2; k++) {
                file = files[k];
                results1.push((function(file) {
                  return deferred(function(arg1) {
                    var reject, resolve;
                    resolve = arg1.resolve, reject = arg1.reject;
                    debug("recursor found file " + file);
                    return emit('files.recurse.found', {
                      path: file
                    }, function(err) {
                      if (err != null) {
                        return reject(err);
                      }
                      try {
                        if (isBinaryFile(file)) {
                          return resolve();
                        }
                      } catch (_error) {}
                      fs.watchFile(file, {
                        interval: 100
                      }, function(curr, prev) {
                        if (!(prev.mtime < curr.mtime)) {
                          return;
                        }
                        return emit('files.watch.reload?', file, function() {
                          var children, enque, filename, objectiveFile, uuid;
                          debug("recursor reloading file " + file);
                          children = objective.root.children;
                          enque = require('./queue').get('objectives').enque;
                          for (uuid in children) {
                            objectiveFile = children[uuid].root.filename;
                            if (file === objectiveFile) {
                              debug("recursor queueing objective from file '" + file + "'");
                              return enque(function(done, file) {
                                var filename;
                                debug("recursor running objective from file '" + file + "'");
                                filename = process.cwd() + sep + file;
                                delete require.cache[filename];
                                try {
                                  require(filename);
                                  return objective.runningChild.then(function() {
                                    debug("recursor done objective from file '" + file + "'");
                                    return done();
                                  });
                                } catch (_error) {
                                  e = _error;
                                  console.log(e);
                                  return done();
                                }
                              })(file);
                            }
                          }
                          try {
                            filename = process.cwd() + sep + file;
                            delete require.cache[filename];
                            return require(filename);
                          } catch (_error) {
                            e = _error;
                            error("\nError loading '" + filename + "'");
                            return error(e.stack);
                          }
                        });
                      });
                      return emit('files.recurse.load?', file, function() {
                        debug("recursor loading file " + file);
                        objective.loading = file;
                        try {
                          require(process.cwd() + sep + file);
                          return resolve();
                        } catch (_error) {
                          e = _error;
                          return emit('files.recurse.load.fatal?', {
                            file: file,
                            error: e
                          }, function(err) {
                            if (err != null) {
                              return reject(err);
                            }
                            return resolve();
                          });
                        }
                      });
                    });
                  });
                })(file));
              }
              return results1;
            })()).then(function(result) {
              return recurse(directories, options, function(err, res) {
                if (err != null) {
                  return reject(err);
                }
                return resolve(res);
              });
            }, function(error) {
              return reject(error);
            });
          });
        });
      })(path));
    }
    return results;
  })()).then(function(result) {
    return callback(null, result);
  }, function(error) {
    return callback(error);
  }, function(notify) {});
};
