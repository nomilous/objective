// Generated by CoffeeScript 1.9.2
var appendToCommand, autoComplete, autoCompleteAssemble, autoCompleteStartsWith, backspace, bell, command, commands, createEvent, cursorScroll, emit, endSearch, fs, history, historyCursor, historyFile, historyScroll, historySearch, keypress, lastPart, latestCommand, normalize, offset, postPrompt, prePrompt, promptWidth, ref, runCommand, running, searchLine, searching, setPrompt, showHelp, updateSearch, writeAutoCompletePosibilities, writePrompt;

ref = require('./pipeline'), createEvent = ref.createEvent, emit = ref.emit;

console.log('todo: fix ^r then enter on empty result running command');

createEvent('prompt.commands.register.ask');

keypress = require('keypress');

fs = require('fs');

normalize = require('path').normalize;

command = '';

prePrompt = '> ';

postPrompt = '';

promptWidth = prePrompt.length;

offset = 0;

searching = false;

running = false;

bell = function() {
  return process.stdout.write('\u0007');
};

commands = {
  'help': {
    run: function(args, callback) {
      return showHelp(args, callback);
    },
    help: "\n\"hope this helps\"\n",
    autoComplete: function(args, callback) {
      var cmd;
      return callback(null, (function() {
        var results;
        results = [];
        for (cmd in commands) {
          results.push(cmd);
        }
        return results;
      })());
    }
  }
};

showHelp = function(args, callback) {
  var cmd;
  if (args.length > 0) {
    cmd = args[0];
    if (commands[cmd] == null) {
      console.log("\n" + cmd + " does not exist\n");
      return callback();
    }
    console.log(commands[cmd].help || ("\nno help for " + cmd + "\n"));
    return callback();
  }
  console.log();
  console.log("help [command]           Per command help");
  console.log();
  for (cmd in commands) {
    process.stdout.write(cmd);
    process.stdout.cursorTo(25);
    console.log(commands[cmd].description || 'No description.');
  }
  return callback();
};

setPrompt = function(newPrompt) {
  prePrompt = newPrompt;
  return promptWidth = prePrompt.length;
};

writePrompt = function(newline) {
  if (newline) {
    process.stdout.write("\n" + prePrompt + command + postPrompt);
  } else {
    process.stdout.write(prePrompt + command + postPrompt);
  }
  return process.stdout.cursorTo(promptWidth + command.length);
};

appendToCommand = function(char) {
  var ch, chars, j, len;
  chars = [];
  for (j = 0, len = command.length; j < len; j++) {
    ch = command[j];
    chars.push(ch);
  }
  chars.splice(command.length - offset, 0, char);
  command = chars.join('');
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  writePrompt();
  process.stdout.cursorTo(command.length - offset + promptWidth);
  if (searching) {
    return updateSearch();
  }
};

runCommand = function() {
  var args, callback, cmd, err;
  command = command.trim();
  if (command.length === 0) {
    return writePrompt(true);
  }
  running = true;
  args = command.split(' ');
  cmd = args[0];
  args = args.slice(1);
  if (commands[cmd] != null) {
    if (history[0] !== command) {
      history.unshift(command);
    }
    while (history.length > 2000) {
      history.pop();
    }
    console.log();
    command = '';
    try {
      callback = function(err, res) {
        running = false;
        if (err != null) {
          return console.log("" + (err.toString()));
        }
        if (res != null) {
          return console.log(res);
        }
        return writePrompt(true);
      };
      callback.write = function(text) {
        process.stdout.clearLine();
        process.stdout.cursorTo(0);
        return process.stdout.write(text.toString());
      };
      callback.writeLine = function(text) {
        return console.log(text);
      };
      commands[cmd].run(args, callback);
      return;
    } catch (_error) {
      err = _error;
      running = false;
      console.log("" + (err.toString()));
    }
  } else {
    console.log("\n" + cmd + ": command not found");
    command = '';
    running = false;
  }
  return writePrompt(true);
};

lastPart = void 0;

autoCompleteStartsWith = function(part, array) {
  var accum, col, j, k, len, letter, newArray, word;
  part || (part = '');
  accum = '';
  if (part.length > 0) {
    newArray = [];
    array.map(function(word) {
      if (word.indexOf(part) === 0) {
        return newArray.push(word);
      }
    });
    if (newArray.length === 1) {
      return [newArray[0], true, newArray];
    }
    if (newArray.length !== 0) {
      array = newArray;
    } else {
      bell();
      return [null, false, []];
    }
  }
  for (col = j = 0; j <= 99; col = ++j) {
    letter = void 0;
    for (k = 0, len = array.length; k < len; k++) {
      word = array[k];
      letter || (letter = word[col]);
      if (letter !== word[col]) {
        return [accum, false, array];
      }
    }
    accum += letter;
  }
  return [accum, false, array];
};

writeAutoCompletePosibilities = function(array, type) {
  var last, nextPaths, path;
  if (type === 'path') {
    last = command.split(' ').pop();
    nextPaths = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = array.length; j < len; j++) {
        path = array[j];
        results.push(path.substr(last.length));
      }
      return results;
    })();
    console.log("\n\n" + (nextPaths.join('\n')));
    return;
  }
  return console.log("\n\n" + (array.join('\n')));
};

autoCompleteAssemble = function(possibilities, args, func, arg) {
  var fullMatch, matches, part, type;
  part = arg[0], fullMatch = arg[1], matches = arg[2];
  if (part == null) {
    return;
  }
  type = void 0;
  try {
    type = func.type;
  } catch (_error) {}
  if (fullMatch) {
    command = command.substr(0, command.length - args[0].length);
    command += part + ' ';
    process.stdout.clearLine();
    process.stdout.cursorTo(0);
    writePrompt();
    lastPart = void 0;
    return;
  }
  if (part.length === 0) {
    writeAutoCompletePosibilities(possibilities, type);
    writePrompt(true);
    lastPart = void 0;
    return;
  }
  if (part === lastPart) {
    writeAutoCompletePosibilities(matches, type);
    console.log();
  }
  lastPart = part;
  command = command.substr(0, command.length - args[0].length);
  command += part;
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  return writePrompt();
};

autoComplete = function() {
  var args, cmd, contents, e, err, f, func, j, len, path, possibilities, stat;
  offset = 0;
  if (command.trim().length === 0) {
    showHelp([], function() {});
    writePrompt(true);
    return;
  }
  args = command.split(' ');
  cmd = args[0];
  args = args.slice(1);
  if (commands[cmd] != null) {
    func = commands[cmd].autoComplete;
    if (typeof func === 'function') {
      try {
        commands[cmd].autoComplete(args, function(err, possibilities) {
          if (err != null) {
            console.log();
            console.log("Error in autoComplete " + (err.toString()));
            command = '';
            writePrompt(true);
          }
          if (args.length > 1) {
            console.log();
            console.log("Only first argument cam be auto completed.");
            writePrompt(true);
            return;
          }
          return autoCompleteAssemble(possibilities, args, func, autoCompleteStartsWith(args[0], possibilities));
        });
      } catch (_error) {
        err = _error;
        console.log();
        console.log("Error in autoComplete " + (err.toString()));
        command = '';
        writePrompt(true);
      }
    } else if (func.type === 'path') {
      args = command.split(' ');
      cmd = args[0];
      args = args.slice(1);
      path = args[args.length - 1];
      console.log({
        p: path
      });
      possibilities = [];
      contents = fs.readdirSync(path);
      for (j = 0, len = contents.length; j < len; j++) {
        f = contents[j];
        f = normalize(path + '/' + f);
        try {
          stat = fs.lstatSync(f);
          if (stat.isDirectory()) {
            f += '/';
          }
          if (func.ignoreFiles) {
            if (stat.isDirectory()) {
              possibilities.push(f);
            }
            continue;
          }
          possibilities.push(f);
        } catch (_error) {
          e = _error;
          console.log();
          console.log("Error in autoComplete " + (err.toString()));
          writePrompt(true);
        }
      }
      autoCompleteAssemble(possibilities, args, func, autoCompleteStartsWith(args[0], possibilities));
      if (command.match(/\/\s$/)) {
        command = command.substr(0, command.length - 1);
        process.stdout.clearLine();
        process.stdout.cursorTo(0);
        writePrompt();
      }
    }
    return;
  }
  possibilities = (function() {
    var results;
    results = [];
    for (cmd in commands) {
      results.push(cmd);
    }
    return results;
  })();
  autoCompleteAssemble(possibilities, [command], null, autoCompleteStartsWith(command, possibilities));
  if (command.match(/\s$/)) {
    cmd = command.substr(0, command.length - 1);
    func = commands[cmd].autoComplete;
    if (func.type === 'path' && (func.startIn != null)) {
      command = cmd + ' ' + func.startIn;
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
      return writePrompt();
    }
  }
};

historyFile = process.env.HOME + '/.objective/command_history';

historyCursor = 0;

latestCommand = '';

history = [];

history = (function() {
  try {
    return fs.readFileSync(historyFile).toString().trim().split('\n');
  } catch (_error) {}
})();

process.on('exit', function() {
  try {
    return fs.writeFileSync(historyFile, history.join('\n'));
  } catch (_error) {}
});

historyScroll = function(direction) {
  switch (direction) {
    case 'up':
      if (historyCursor === 0) {
        latestCommand = command;
      }
      if (!(historyCursor >= history.length)) {
        historyCursor++;
      }
      break;
    case 'down':
      if (historyCursor !== 0) {
        historyCursor--;
      }
  }
  command = history[historyCursor - 1] || latestCommand;
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  return writePrompt();
};

historySearch = function() {
  if (searching) {
    return updateSearch(searchLine);
  }
  searching = true;
  command = '';
  setPrompt('(search)\'');
  postPrompt = '\':';
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  return writePrompt();
};

searchLine = 0;

updateSearch = function(start) {
  var found, i, j, line, position, ref1, ref2;
  if (start == null) {
    start = 0;
  }
  searchLine = start;
  if (command.length === 0) {
    process.stdout.clearLine();
    process.stdout.cursorTo(0);
    postPrompt = '\':';
    writePrompt(false);
    return;
  }
  found = false;
  for (i = j = ref1 = start, ref2 = history.length; ref1 <= ref2 ? j <= ref2 : j >= ref2; i = ref1 <= ref2 ? ++j : --j) {
    line = history[i] || '';
    position = line.indexOf(command);
    if (position === -1) {
      searchLine++;
      continue;
    }
    postPrompt = "': " + line;
    searchLine++;
    found = true;
    break;
  }
  if (!found) {
    postPrompt = '\':';
  }
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  return writePrompt(false);
};

endSearch = function() {
  command = history[searchLine - 1] || '';
  postPrompt = '';
  setPrompt('> ');
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  writePrompt(false);
  return searching = false;
};

cursorScroll = function(direction) {
  var position;
  position = command.length - offset;
  switch (direction) {
    case 'left':
      if (position !== 0) {
        offset++;
        position--;
      }
      break;
    case 'right':
      if (!(position >= command.length)) {
        offset--;
        position++;
      }
  }
  return process.stdout.cursorTo(position + promptWidth);
};

backspace = function() {
  var char, chars, j, len, position;
  if (command.length === 0) {
    return;
  }
  position = command.length - offset - 1;
  if (position < 0) {
    return;
  }
  chars = [];
  for (j = 0, len = command.length; j < len; j++) {
    char = command[j];
    chars.push(char);
  }
  chars.splice(position, 1);
  command = chars.join('');
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  writePrompt();
  process.stdout.cursorTo(position + promptWidth);
  if (searching) {
    return updateSearch();
  }
};

module.exports = function(done) {
  var registrar;
  registrar = {};
  Object.defineProperty(registrar, 'create', {
    get: function() {
      return function(name, config) {
        if (commands[name] != null) {
          if (config.altname == null) {
            throw new Error("Command name collision on '" + name + "'");
          }
          name = config.altname;
        }
        return commands[name] = config;
      };
    }
  });
  return emit('prompt.commands.register.ask', registrar, function(err, res) {
    if (err != null) {
      return done(err);
    }
    keypress(process.stdin);
    process.stdin.setRawMode(true);
    process.stdin.on('keypress', function(ch, key) {
      if (running) {
        return;
      }
      try {
        if (key.name === 'return') {
          historyCursor = 0;
          if (searching) {
            endSearch();
          }
          if (command.length > 0) {
            return runCommand();
          }
          return writePrompt(true);
        }
      } catch (_error) {}
      if (key == null) {
        return appendToCommand(ch);
      }
      if ((ch != null) && ch.match(/^[a-zA-Z0-9_]*$/)) {
        return appendToCommand(ch);
      }
      try {
        if (key.ctrl && (key.name === 'c' || key.name === 'd')) {
          historyCursor = 0;
          if (searching) {
            endSearch();
            command = '';
            process.stdout.clearLine();
            process.stdout.cursorTo(0);
            writePrompt(false);
            return;
          }
          try {
            if (command.length > 0) {
              command = '';
              return writePrompt(true);
            }
          } catch (_error) {}
          try {
            done();
          } catch (_error) {}
          return process.exit(1);
        }
      } catch (_error) {}
      if ((ch != null) && ch === ' ') {
        return appendToCommand(ch);
      }
      try {
        if (key.name === 'tab') {
          if (searching) {
            return endSearch();
          }
          return autoComplete();
        }
      } catch (_error) {}
      try {
        if (key.name === 'backspace') {
          return backspace();
        }
      } catch (_error) {}
      try {
        if (key.ctrl && key.name === 'r') {
          return historySearch();
        }
      } catch (_error) {}
      try {
        if (key.name === 'up' || key.name === 'down') {
          if (searching) {
            return;
          }
          return historyScroll(key.name);
        }
      } catch (_error) {}
      try {
        if (key.name === 'left' || key.name === 'right') {
          return cursorScroll(key.name);
        }
      } catch (_error) {}
    });
    console.log();
    console.log("    help . . gets some");
    console.log("    tab  . . auto completes command ((Twice)");
    console.log("    ^c . . . quits or clearsline");
    console.log("    ^r . . . reverse searches command history");
    console.log();
    console.log();
    return writePrompt();
  });
};
