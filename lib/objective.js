// Generated by CoffeeScript 1.9.2
var Objective, TODO, When, debug, deferred, enque, error, fs, info, path, pipe, pipeline, program, ref, ref1, required, run, util, uuid;

if (process.env.DEBUG == null) {
  process.env.DEBUG = 'info,error,TODO';
}

ref = require('also'), deferred = ref.deferred, pipeline = ref.pipeline, util = ref.util, When = ref.When;

ref1 = require('./logger'), info = ref1.info, debug = ref1.debug, error = ref1.error, TODO = ref1.TODO;

TODO('exit codes, and after recurse for all test results');

TODO('add flag to not queue child objectives');

TODO('per module debug');

pipe = require('./globals/pipeline');

pipe.createEvent('objective.result');

pipe.createEvent('objective.notify');

pipe.createEvent('objective.queued');

enque = require('./globals/queue').create('objectives').enque;

path = require('path');

fs = require('fs');

uuid = require('uuid');

required = {};

run = void 0;

module.exports = Objective = function(config) {
  var base, count, loadGlobal, moduleName, oldConfig, running, title;
  if (config == null) {
    config = {};
  }
  running = null;
  if (typeof config === 'string') {
    title = config;
    config = arguments[1] || {};
    config.title = title;
  }
  if (objective.root != null) {
    if (objective.root.children[config.uuid] != null) {
      oldConfig = objective.root.children[config.uuid].root;
      objective.prompt.startbg();
      debug("Updating '" + config.title + "' from '" + oldConfig.filename + "'");
      config.filename = oldConfig.filename;
      objective.root.children[config.uuid] = {
        root: config
      };
      objective.root.children[config.uuid].doRun = true;
    } else {
      config.filename = objective.loading;
      info("Loading '" + config.title + "' from '" + config.filename + "'");
      objective.root.children[config.uuid] = {
        root: config
      };
    }
    return {
      run: function(fn) {
        var childRunning, e, moduleFile, name;
        run = When.defer();
        objective.root.children[config.uuid].run = fn;
        if (!(program.run || objective.root.children[config.uuid].doRun)) {
          return run.resolve();
        }
        TODO('flag to disable require cache flushing');
        for (moduleFile in require.cache) {
          if (required[moduleFile]) {
            continue;
          }
          delete require.cache[moduleFile];
        }
        info("Running '" + config.title + "' from '" + config.filename + "'");
        try {
          for (name in objective.plugins) {
            try {
              objective.plugins[name].before(config);
            } catch (_error) {}
          }
          childRunning = fn();
          if ((childRunning != null) && typeof childRunning.then === 'function') {
            childRunning.then(function(result) {
              debug({
                objective_result: result
              });
              return pipe.emit('objective.result', {
                error: null,
                result: result
              }, function() {
                objective.prompt.endbg();
                return run.resolve();
              });
            }, function(err) {
              error({
                objective_error: err
              });
              return pipe.emit('objective.result', {
                error: err,
                result: null
              }, function() {
                objective.prompt.endbg();
                return run.resolve();
              });
            }, function(message) {
              debug({
                objective_notify: notify
              });
              return pipe.emit('objective.notify', {
                message: message
              }, function() {
                return run.resolve();
              });
            });
            if (typeof childRunning.start === 'function') {
              return childRunning.start();
            }
          } else {
            objective.prompt.endbg();
            return run.resolve();
          }
        } catch (_error) {
          e = _error;
          error(e.stack + '\n');
          return run.resolve();
        }
      }
    };
  }
  objective.root = config;
  (base = objective.root).children || (base.children = {});
  run = function(e) {
    console.log('Missing .run(fn)');
    if (e != null) {
      return console.log(e.toString());
    }
  };
  loadGlobal = function(name, path) {
    if (objective[name] != null) {
      info("Warning: global " + name + " not loaded.");
      return;
    }
    info("Loading global 'objective." + name + "'");
    objective[name] = require(path);
    if (name === 'coffee') {
      objective.coffee.register();
    }
    objective.globals || (objective.globals = []);
    return objective.globals.push(name);
  };
  loadGlobal('recurse', './globals/recurse');
  loadGlobal('coffee', 'coffee-script');
  loadGlobal('uplink', './globals/uplink');
  loadGlobal('prompt', './globals/prompt');
  loadGlobal('pipe', './globals/pipeline');
  loadGlobal('injector', './globals/injector');
  loadGlobal('queue', './globals/queue');
  config.plugins || (config.plugins = []);
  objective.plugins || (objective.plugins = {});
  count = 1;
  pipeline((function() {
    var j, len, ref2, results;
    ref2 = config.plugins;
    results = [];
    for (j = 0, len = ref2.length; j < len; j++) {
      moduleName = ref2[j];
      results.push((function(moduleName) {
        return deferred(function(arg) {
          var camel, e, i, k, name, p, parts, ref3, reject, resolve;
          resolve = arg.resolve, reject = arg.reject;
          if (typeof moduleName !== 'string') {
            if (!moduleName.name) {
              moduleName.name = "plugin" + (count++);
              info("Warning: Plugin without name. (set .name property)");
            }
            if (global[moduleName.name] != null) {
              return reject(new Error("Plugin " + moduleName + " collides with global." + moduleName.name));
            }
            info("Loading plugin '" + moduleName + "' as '" + moduleName.name + "'");
            global[moduleName.name] = moduleName;
            try {
              moduleName.init(function(e) {
                if (e != null) {
                  error("Failed loading plugin '" + moduleName.name + "'");
                }
                if (e != null) {
                  return reject(e);
                }
                return resolve();
              });
            } catch (_error) {
              e = _error;
              error("Failed loading plugin '" + moduleName.name + "'");
              return reject(e);
            }
            return;
          }
          name = moduleName.split(path.sep).pop().replace(/objective-/, '');
          if (name.match(/[-\._]/)) {
            parts = name.split(/[-\._]/);
            camel = parts[0];
            for (i = k = 1, ref3 = parts.length - 1; 1 <= ref3 ? k <= ref3 : k >= ref3; i = 1 <= ref3 ? ++k : --k) {
              p = parts[i][0].toUpperCase();
              camel += p + parts[i].slice(1);
            }
            name = camel;
          }
          if (global[name] != null) {
            return reject(new Error("Plugin " + moduleName + " collides with global." + name));
          }
          try {
            if (moduleName.match(/^\./)) {
              moduleName = path.normalize(process.cwd() + path.sep + moduleName);
            }
            global[name] = require(moduleName);
          } catch (_error) {
            e = _error;
            return reject(e);
          }
          info("Loading plugin '" + moduleName + "' as '" + name + "'");
          try {
            return global[name].init(function(e) {
              if (e != null) {
                error("Failed loading plugin '" + name + "'");
              }
              if (e != null) {
                return reject(e);
              }
              objective.plugins[name] = global[name];
              return resolve();
            });
          } catch (_error) {
            e = _error;
            error("Failed loading plugin '" + name + "'");
            return reject(e);
          }
        });
      })(moduleName));
    }
    return results;
  })()).then(function(result) {
    TODO('promises after run to emit');
    return process.nextTick(function() {
      var dir, filename;
      for (filename in require.cache) {
        required[filename] = {};
      }
      TODO('Handle recursing, get root promise (running) first (or something)');
      TODO('Or remove --recurse (similar needed for test all silently');
      if (program.recurse != null) {
        if (typeof program.recurse !== 'string') {
          info("\nRecurse needs [dir]");
          return;
        }
        dir = program.recurse;
        return objective.recurse(dir, function(err) {
          if (err != null) {
            return run(err);
          }
          return run(null);
        });
      }
      if (program.prompt) {
        return objective.prompt();
      }
      return running = objective.injector({}, run);
    });
  }, function(err) {
    if (program.prompt) {
      error(err.stack);
      program.exit(1);
    }
    return process.nextTick(function() {
      running = objective.injector({
        error: err
      }, run);
      if (!((running != null) && typeof running.then === 'function')) {
        return process.exit(1);
      }
    });
  });
  return {
    run: function(fn) {
      return run = fn;
    }
  };
};

module.exports.promise = function() {
  return master.promise;
};

Object.defineProperty(global, 'objective', {
  get: function() {
    return Objective;
  },
  configurable: false
});

Object.defineProperty(objective, 'runningChild', {
  get: function() {
    return run.promise || false;
  },
  configurable: false
});

program = require('./cli');

objective.logger = require('./logger');

program.start();
