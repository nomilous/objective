// Generated by CoffeeScript 1.9.2
var Objective, TODO, child, debug, defer, error, fs, info, init, path, pipe, program, ref, run,
  slice = [].slice;

if (process.env.DEBUG == null) {
  process.env.DEBUG = 'info,error,TODO';
}

defer = require('when').defer;

ref = require('./logger'), info = ref.info, debug = ref.debug, error = ref.error, TODO = ref.TODO;

TODO('fail on multiple objectives in one file, even nested');

TODO('exit codes, and after recurse for all test results');

TODO('add flag to not queue child objectives');

TODO('per module debug');

TODO('config into json appendage');

pipe = require('./globals/pipeline');

pipe.createEvent('objective.result');

pipe.createEvent('objective.notify');

TODO('queue objective in here, not in recursor and cli');

child = require('./objective_child');

init = require('./objective_init');

path = require('path');

fs = require('fs');

module.exports = Objective = function() {
  var args, callback, config, objectiveFn, title;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  title = args[0];
  config = args[1];
  callback = args[2];
  if (typeof title === 'string') {
    if (typeof config === 'object') {
      config.title = title;
    }
    if (typeof config === 'undefined') {
      config = {
        title: title
      };
    }
    if (typeof config === 'function') {
      callback = config;
      config = {
        title: title
      };
    }
  }
  if (typeof title === 'object') {
    if (typeof config === 'function') {
      config = title;
      callback = config;
    }
  }
  if (typeof title === 'function') {
    callback = title;
    config = {};
  }
  if (config.title == null) {
    config.title = 'Untitled Objective';
  }
  if ((objective.node != null) || objective.noRoot) {
    return child.load(config, callback);
  }
  objective.node = config;
  objectiveFn = function() {};
  init.globals().then(function() {
    return init.user(config);
  }).then(function() {
    return init.plugins(config);
  }).then(function() {
    return run(config, objectiveFn);
  })["catch"](function(e) {
    console.log(e.stack);
    return process.exit(1);
  });
  return {
    run: function(fn) {
      var caller;
      caller = objective.getCallerFileName(2);
      caller = caller.replace(process.cwd() + path.sep, '');
      if (path.dirname(caller) !== '.') {
        console.log('Must run objective in current directory (for now)');
        process.exit(1);
      }
      return objectiveFn = fn;
    }
  };
};

run = function(config, objectiveFn) {
  var clearRequire, filename, required, running;
  required = {};
  for (filename in require.cache) {
    required[filename] = {};
  }
  clearRequire = function() {
    var results;
    results = [];
    for (filename in require.cache) {
      if (required[filename] != null) {
        continue;
      }
      delete require.cache[filename];
      results.push(debug("Removed " + filename + " from require cache"));
    }
    return results;
  };
  if (objectiveFn.toString() === 'function () {}') {
    console.log('Nothing to do.');
    process.exit(0);
  }
  running = objective.injector({}, objectiveFn);
  if ((running != null) && (running.then != null) && typeof running.then === 'function') {
    running.then(function(result) {
      return pipe.emit('objective.result', {
        error: null,
        result: result
      }, function() {});
    }, function(error) {
      return pipe.emit('objective.result', {
        error: error,
        result: null
      }, function() {});
    }, function(notify) {
      return pipe.emit('objective.notify', {
        message: notify
      }, function() {});
    });
    if ((running.start != null) && typeof running.start === 'function') {
      return running.start();
    }
  }
};

Object.defineProperty(global, 'objective', {
  get: function() {
    return Objective;
  },
  configurable: false
});

Object.defineProperty(objective, 'waiting', {
  get: function() {
    return child.nextPromise();
  },
  configurable: false
});

Object.defineProperty(objective, 'getCallerFileName', {
  get: function() {
    return function(depth) {
      var origPrepareStackTrace, stack;
      origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack) {
        return stack;
      };
      stack = (new Error).stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[depth].getFileName();
    };
  },
  configurable: false
});

program = require('./cli');

objective.logger = require('./logger');

program.start();
